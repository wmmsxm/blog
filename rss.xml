<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>公子玄襄BLOG</title>
        <link>/blog/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.90.1 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>wmmsxm@163.com (wmmsxm)</managingEditor>
        
        
            <webMaster>wmmsxm@163.com (wmmsxm)</webMaster>
        
        
            <copyright>Copyright © 2022 WuMengMeng</copyright>
        
        <lastBuildDate>Tue, 12 Jul 2022 10:05:29 &#43;0000</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="/blog/rss.xml" />
        
        
            <item>
                <title>Docker_Desktop学习(三) Kubernetes-Dashboard安装</title>
                <link>/blog/posts/docker-desktop-three/</link>
                <guid isPermaLink="true">/blog/posts/docker-desktop-three/</guid>
                <pubDate>Sat, 04 Dec 2021 13:35:05 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker_desktop学习三-kubernetes-dashboard安装center&#34;&gt;&lt;center&gt;Docker_Desktop学习(三) Kubernetes-Dashboard安装&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;创建kubernetes-dashboard服务和对应的pod&#34;&gt;创建kubernetes-dashboard服务和对应的pod&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果发现链接失效，可以访问&lt;a href=&#34;https://github.com/kubernetes/dashboard&#34;&gt;https://github.com/kubernetes/dashboard&lt;/a&gt;,查找最新的链接。&lt;br&gt;
或者将yaml内容存到本地，使用下面命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl create -f kubernetes-dashboard.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd3_1.png&#34; alt=&#34;dd3-1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;检查kubernetes-dashboard应用状态&#34;&gt;检查kubernetes-dashboard应用状态&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pod -n kubernetes-dashboard  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd3_3.png&#34; alt=&#34;dd3-3&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用代理访问dashboard&#34;&gt;使用代理访问dashboard&lt;/h3&gt;
&lt;p&gt;使用代理命令&lt;code&gt;kubectl proxy&lt;/code&gt;， 默认端口是8001，可以使用 &lt;code&gt;-p xxx&lt;/code&gt;指定端口，比如&lt;code&gt;kubectl proxy -p 8112&lt;/code&gt;,&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/docker_desktop/dd3_2.png&#34; alt=&#34;dd3-2&#34;&gt;&lt;br&gt;
然后在通过&lt;a href=&#34;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login&#34;&gt;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login&lt;/a&gt;访问dashboard&lt;/p&gt;
&lt;h3 id=&#34;token访问&#34;&gt;token访问&lt;/h3&gt;
&lt;p&gt;首次访问时会阻拦，继续访问需要选择验证方式，会有kubeconfig和令牌两种方式，我们选择令牌token。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl -n kube-system describe secret default | awk &#39;$1==&amp;quot;token:&amp;quot;{print $2}&#39;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行此命令获取token填入即可正常访问。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker-desktop/">docker-desktop</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker-desktop/">docker-desktop</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker_Desktop学习(二) Kubernetes</title>
                <link>/blog/posts/docker-desktop-two/</link>
                <guid isPermaLink="true">/blog/posts/docker-desktop-two/</guid>
                <pubDate>Fri, 03 Dec 2021 14:24:09 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker_desktop学习二-kubernetescenter&#34;&gt;&lt;center&gt;Docker_Desktop学习(二) Kubernetes&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;docker_desktop安装kubernetes&#34;&gt;docker_desktop安装Kubernetes&lt;/h3&gt;
&lt;p&gt;使用docker desktop安装kubernetes，打开settings，选择Kubernetes, Enable Kubernetes前打钩，然后点击右下角 Apply &amp;amp; Restart,耐心等待即可。&lt;img src=&#34;/blog/blog/images/docker_desktop/dd2_1.png&#34; alt=&#34;dd2-1&#34;&gt;&lt;br&gt;
等待一段时间后，如果成功即可；未成功则使用下面的方法安装&lt;/p&gt;
&lt;h3 id=&#34;使用k8s-for-docker-desktop方式安装&#34;&gt;使用k8s-for-docker-desktop方式安装&lt;/h3&gt;
&lt;p&gt;1、git下载k8s-for-docker-desktop&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/AliyunContainerService/k8s-for-docker-desktop.git
cd k8s-for-docker-desktop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd2_2.png&#34; alt=&#34;dd2-2&#34;&gt;&lt;br&gt;
2、 然后cmd命令窗口，执行命令&lt;code&gt;.\load_images.ps1&lt;/code&gt;， 等待下载镜像&lt;br&gt;
3、 回到docker desktop的settings中kubernetes，点击&amp;quot;Reset Kubernetes Cluster&amp;quot;,清空docker desktop的kubernetes的缓存。  &lt;img src=&#34;/blog/blog/images/docker_desktop/dd2_3.png&#34; alt=&#34;dd2-3&#34;&gt;&lt;br&gt;
4、 重新点击Enable Kubernetes前打钩，然后点击右下角 Apply &amp;amp; Restart。等待重启之后即可安装成功。&lt;/p&gt;
&lt;h3 id=&#34;kubectl基础命令&#34;&gt;kubectl基础命令&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd2_4.png&#34; alt=&#34;dd2-4&#34;&gt;&lt;br&gt;
基础命令包括 create、delete、get、run、expose、set、explain、edit&lt;/p&gt;
&lt;h4 id=&#34;create-命令根据文件或者输入来创建资源&#34;&gt;create 命令：根据文件或者输入来创建资源&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 创建Deployment和Service资源
$ kubectl create -f demo-deployment.yaml
$ kubectl create -f demo-service.yaml   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;delete-命令删除资源&#34;&gt;delete 命令：删除资源&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 根据yaml文件删除对应的资源，但是yaml文件并不会被删除，这样更加高效
$ kubectl delete -f demo-deployment.yaml 
$ kubectl delete -f demo-service.yaml

# 也可以通过具体的资源名称来进行删除，使用这个删除资源，同时删除deployment和service资源

$ kubectl delete 具体的资源名称
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;get-命令-获得资源信息&#34;&gt;get 命令 ：获得资源信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 查看所有的资源信息
$ kubectl get all
$ kubectl get --all-namespaces

# 查看pod列表
$ kubectl get pod

# 显示pod节点的标签信息
$ kubectl get pod --show-labels

# 根据指定标签匹配到具体的pod
$ kubectl get pods -l app=example

# 查看node节点列表
$ kubectl get node 

# 显示node节点的标签信息
$ kubectl get node --show-labels

# 查看pod详细信息，也就是可以查看pod具体运行在哪个节点上（ip地址信息）
$ kubectl get pod -o wide

# 查看服务的详细信息，显示了服务名称，类型，集群ip，端口，时间等信息
$ kubectl get svc
$ kubectl get svc -n kube-system

# 查看命名空间
$ kubectl get ns
$ kubectl get namespaces

# 查看所有pod所属的命名空间
$ kubectl get pod --all-namespaces

# 查看所有pod所属的命名空间并且查看都在哪些节点上运行
$ kubectl get pod --all-namespaces  -o wide

# 查看目前所有的replica set，显示了所有的pod的副本数，以及他们的可用数量以及状态等信息
$ kubectl get rs

# 查看已经部署了的所有应用，可以看到容器，以及容器所用的镜像，标签等信息
$ kubectl get deploy -o wide
$ kubectl get deployments -o wide
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;run-命令在集群中创建并运行一个或多个容器镜像&#34;&gt;run 命令：在集群中创建并运行一个或多个容器镜像。&lt;/h4&gt;
&lt;p&gt;run语法：&lt;code&gt;run NAME --image=image [--env=&amp;quot;key=value&amp;quot;] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 示例，运行一个名称为nginx，副本数为3，标签为app=example，镜像为nginx:1.10，端口为80的容器实例

$ kubectl run nginx --replicas=3 --labels=&amp;quot;app=example&amp;quot; --image=nginx:1.10 --port=80

# 示例，运行一个名称为nginx，副本数为3，标签为app=example，镜像为nginx:1.10，端口为80的容器实例，并绑定到k8s-node1上
$ kubectl run nginx --image=nginx:1.10 --replicas=3 --labels=&amp;quot;app=example&amp;quot; --port=80 --overrides=&#39;{&amp;quot;apiVersion&amp;quot;:&amp;quot;apps/v1&amp;quot;,&amp;quot;spec&amp;quot;:{&amp;quot;template&amp;quot;:{&amp;quot;spec&amp;quot;:{&amp;quot;nodeSelector&amp;quot;:{&amp;quot;kubernetes.io/hostname&amp;quot;:&amp;quot;k8s-node1&amp;quot;}}}}}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;expose-命令创建一个service服务并且暴露端口让外部可以访问&#34;&gt;expose 命令：创建一个service服务，并且暴露端口让外部可以访问&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 创建一个nginx服务并且暴露端口让外界可以访问

$ kubectl expose deployment nginx --port=88 --type=NodePort --target-port=80 --name=nginx-service
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;set-命令配置应用的一些特定资源也可以修改应用已有的资源&#34;&gt;set 命令：配置应用的一些特定资源，也可以修改应用已有的资源&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;使用 kubectl set --help查看，它的子命令，env，image，resources，selector，serviceaccount，subject。

语法: resources (-f FILENAME | TYPE NAME) ([--limits=LIMITS &amp;amp; --requests=REQUESTS]
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;kubectl-set-resources-命令&#34;&gt;kubectl set resources 命令&lt;/h5&gt;
&lt;p&gt;这个命令用于设置资源的一些范围限制。&lt;br&gt;
资源对象中的Pod可以指定计算资源需求（CPU-单位m、内存-单位Mi），即使用的最小资源请求（Requests），限制（Limits）的最大资源需求，Pod将保证使用在设置的资源数量范围。&lt;br&gt;
对于每个Pod资源，如果指定了Limits（限制）值，并省略了Requests（请求），则Requests默认为Limits的值。&lt;br&gt;
# 将deployment的nginx容器cpu限制为“200m”，将内存设置为“512Mi”
$ kubectl set resources deployment nginx -c=nginx --limits=cpu=200m,memory=512Mi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 设置所有nginx容器中 Requests和Limits
$ kubectl set resources deployment nginx --limits=cpu=200m,memory=512Mi --requests=cpu=100m,memory=256Mi

# 删除nginx中容器的计算资源值
$ kubectl set resources deployment nginx --limits=cpu=0,memory=0 --requests=cpu=0,memory=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;kubectl-set-selector-命令&#34;&gt;kubectl set selector 命令&lt;/h4&gt;
&lt;p&gt;设置资源的 selector（选择器）。如果在调用&amp;quot;set selector&amp;quot;命令之前已经存在选择器，则新创建的选择器将覆盖原来的选择器。&lt;br&gt;
selector必须以字母或数字开头，最多包含63个字符，可使用：字母、数字、连字符&amp;quot; - &amp;quot; 、点&amp;quot;.&amp;quot;和下划线&amp;quot; _ &amp;quot;。如果指定了--resource-version，则更新将使用此资源版本，否则将使用现有的资源版本。&lt;br&gt;
注意：目前selector命令只能用于Service对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：selector (-f FILENAME | TYPE NAME) EXPRESSIONS [--resource-version=version]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;kubectl-set-image-命令&#34;&gt;kubectl set image 命令&lt;/h4&gt;
&lt;p&gt;​用于更新现有资源的容器镜像。&lt;br&gt;
可用资源对象包括：pod (po)、replicationcontroller (rc)、deployment (deploy)、daemonset (ds)、job、replicaset (rs)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法：image (-f FILENAME | TYPE NAME) CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N 

# 将deployment中的nginx容器镜像设置为“nginx：1.9.1”
$ kubectl set image deployment/nginx busybox=busybox nginx=nginx:1.9.1

# 所有deployment和rc的nginx容器镜像更新为“nginx：1.9.1”
$ kubectl set image deployments,rc nginx=nginx:1.9.1 --all

# 将daemonset abc的所有容器镜像更新为“nginx：1.9.1”
$ kubectl set image daemonset abc *=nginx:1.9.1

# 从本地文件中更新nginx容器镜像
$ kubectl set image -f path/to/file.yaml nginx=nginx:1.9.1 --local -o yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;explain-命令用于显示资源文档信息&#34;&gt;explain 命令：用于显示资源文档信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl explain rs
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;edit-命令-用于编辑资源信息&#34;&gt;edit 命令: 用于编辑资源信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 编辑Deployment nginx的一些信息
$ kubectl edit deployment nginx

# 编辑service类型的nginx的一些信息
$ kubectl edit service/nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;logs-命令输出pod中一个容器的日志&#34;&gt;logs 命令：输出pod中一个容器的日志&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#查看指定pod日志
kubectl logs &amp;lt;pod_name&amp;gt;

#类似tail -f的方式查看
kubectl logs -f &amp;lt;pod_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;describe-命令输出指定资源的详细信息&#34;&gt;describe 命令：输出指定资源的详细信息&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 显示node的详细信息
kubectl describe nodes
kubectl describe node &amp;lt;node-name&amp;gt;

# 显示pod的详细信息
kubectl describe pods
kubectl describe pod &amp;lt;pod-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;进入容器内部&#34;&gt;进入容器内部&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n &amp;lt;命名空间&amp;gt; exec -it &amp;lt;pod-name&amp;gt; sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;创建删除的命名空间&#34;&gt;创建/删除的命名空间&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 创建
kubectl create namespace &amp;lt;namespace&amp;gt;
# 删除
kubectl delete namespace &amp;lt;namespace&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;deployment重启&#34;&gt;deployment重启&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 方式1
kubectl scale deployment {your_deployment_name} --replicas=0 -n {namespace}
kubectl scale deployment {your_deployment_name} --replicas=1 -n {namespace}

# 方式2
kubectl rollout restart {your_deployment_name}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;pod重启&#34;&gt;pod重启&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pod &amp;lt;pod_name&amp;gt; -n &amp;lt;命名空间&amp;gt; -o yaml | kubectl replace --force -f -
&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker-desktop/">docker-desktop</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker-desktop/">docker-desktop</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker_Desktop学习(一) 环境安装</title>
                <link>/blog/posts/docker-desktop-one/</link>
                <guid isPermaLink="true">/blog/posts/docker-desktop-one/</guid>
                <pubDate>Fri, 03 Dec 2021 10:11:26 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker_desktop学习一-环境安装center&#34;&gt;&lt;center&gt;Docker_Desktop学习(一) 环境安装&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;windows安装docker_desktop&#34;&gt;windows安装docker_desktop&lt;/h3&gt;
&lt;p&gt;1、我们先去&lt;a href=&#34;https://www.docker.com/products/docker-desktop&#34;&gt;官网下载安装包&lt;/a&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_1.png&#34; alt=&#34;dd1&#34;&gt;&lt;br&gt;
2、打开安装包加载一会后一般会弹出两个选项,在较旧的Windows10或之前的系统会出现如下所示的相关提示。我们把第一个选上,第二个根据需求选择即可。&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_2.png&#34; alt=&#34;dd2&#34;&gt;&lt;br&gt;
3、如下图,这里推荐使用WSL2。使用WSL2(基于Windows的Linux子系统),如果我们不适用,就会使用Hyper-v虚拟机运行,不过相比于虚拟机,子系统在性能方面更加出色。&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_3.png&#34; alt=&#34;dd3&#34;&gt;在我们选择使用WSL2之后,并且我们也确定打开了如下图所示的Windows功能(如果没有打开,请先百度如何打开wsl。)&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_5.png&#34; alt=&#34;dd5&#34;&gt;&lt;br&gt;
3.1、如果之后安装完成后发生报错可能是WSL2版本比较老,需要更新导致的。&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_4.png&#34; alt=&#34;dd4&#34;&gt;  需要我们自己手动更新一下,我们根据提示去微软官网下载最新版的wsl2安装后即可正常打开。&lt;a href=&#34;https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi&#34;&gt;更新包下载链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;docekr_desktop换源&#34;&gt;docekr_desktop换源&lt;/h3&gt;
&lt;p&gt;在docker_desktop中选择setting,然后选择Docker Engine在其中输入以下源&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &amp;quot;registry-mirrors&amp;quot;: [
    &amp;quot;https://registry.docker-cn.com&amp;quot;,
    &amp;quot;https://docker.mirrors.ustc.edu.cn&amp;quot;,
    &amp;quot;http://hub-mirror.c.163.com&amp;quot;,
    &amp;quot;https://cr.console.aliyun.com/&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker_desktop使用&#34;&gt;docker_desktop使用&lt;/h3&gt;
&lt;p&gt;docker_desktop安装好之后，就可以使用命令窗口操作docker&lt;/p&gt;
&lt;h4 id=&#34;镜像操作&#34;&gt;镜像操作&lt;/h4&gt;
&lt;h5 id=&#34;镜像列表&#34;&gt;镜像列表&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#所有镜像
docker images
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;REPOSITORY&lt;/td&gt;
&lt;td&gt;镜像所在的仓库名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TAG&lt;/td&gt;
&lt;td&gt;镜像标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IMAGEID&lt;/td&gt;
&lt;td&gt;镜像ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATED&lt;/td&gt;
&lt;td&gt;镜像创建日期(不是获取该镜像的日期)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIZE&lt;/td&gt;
&lt;td&gt;镜像大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_6.png&#34; alt=&#34;dd6&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;镜像拉取&#34;&gt;镜像拉取&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#镜像拉取
docker pull 镜像名称
比如
docker pull ubuntu
docker pull ubuntu:16.04
#个人镜像
docker pull 仓库名称/镜像名称
docker pull xuanxiang/mysql
#第三方私库
docker pull 第三方仓库地址/仓库名称/镜像名称
docker pull registry.cn-hangzhou.aliyuncs.com/fhzh/system:1.0.0

&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;镜像删除&#34;&gt;镜像删除&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker image rm 镜像名或者镜像id
docker rmi 镜像名或者镜像id
比如
docker image rm mysql
docker rmi e34a19f7b66d
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;加载镜像&#34;&gt;加载镜像&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run [可选参数] 镜像名 [向启动容器中传入的命令]
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;常用可选参数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;表示以《交互模式》运行容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;会创建一个守护式容器在后台运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;表示容器启动后会进入其命令行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--name&lt;/td&gt;
&lt;td&gt;为创建的容器命名。(默认会随机给名称，不支持中文字符)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;表示目录映射关系，即宿主机目录:容器中目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;表示端口映射，即宿主机端口:容器端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--network=host&lt;/td&gt;
&lt;td&gt;表示将主机的网络环境映射到容器中，使容器的网络与主机相同。(windows和mac不生效)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;容器操作&#34;&gt;容器操作&lt;/h4&gt;
&lt;h5 id=&#34;查看容器&#34;&gt;查看容器&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 查看当前所有正在运行的容器
docker ps
# 查看当前所有容器
docker ps -a
# 使用过滤器
docker ps -f name=指定的名称
# 显示2个上次创建的容器(2可以改变)
docker ps -n 2
# 显示最新创建的容器(包括所有容器)
docker ps -l
# 仅显示ip
docker ps -q
# 显示容器大小
docker ps -s
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CONTAINER ID&lt;/td&gt;
&lt;td&gt;容器id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IMAGE&lt;/td&gt;
&lt;td&gt;镜像ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMMAND&lt;/td&gt;
&lt;td&gt;默认启动命令(启动时会自动执行)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CREATED&lt;/td&gt;
&lt;td&gt;创建容器的日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;STATUS&lt;/td&gt;
&lt;td&gt;当前的状态(启动了多久,多久之前退出等)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PORTS&lt;/td&gt;
&lt;td&gt;映射的端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NAMES&lt;/td&gt;
&lt;td&gt;容器的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker_desktop/dd1_7.png&#34; alt=&#34;dd7&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;启动和关闭容器&#34;&gt;启动和关闭容器&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 停止容器
docker container stop 容器名或者容器id
# 或可简写成
docker stop 容器名或容器id

# 强制关闭容器
docker container kill 容器名或容器id
# 或可简写成
docker kill 容器名或容器id

# 启动容器
docker container start 容器名或容器id
# 或可简写成
docker start 容器名或容器id

# 重启容器
docker restart 容器名或容器id
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;操作后台容器&#34;&gt;操作后台容器&lt;/h5&gt;
&lt;p&gt;我们开启容器后,如果需要在容器内执行命令,可以将后台切换到前台,也可能使用docker命令将我们需要执行的命令传入。&lt;br&gt;
操作方法有很多种,这里我们介绍一些比较常用的方法&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 执行单条命令
docker exec -it 容器名或容器id 执行的命令
#比如
docker exec -it mysql whoami
# 进入容器内部
docker exec -it 容器名或容器id /bin/bash
# 比如
docker exec -it mysql /bin/bash
# 除了exec外还有attach可以使用，attach有弊端，多终端启动attach后，都会同步显示。但如果一个窗口阻塞，其他窗口也无法再进行操作。
docker attach 容器名或容器id
docker attach mysql
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;exec可选参数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;会创建一个守护式容器在后台运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;设置环境变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;表示以《交互模式》运行容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;表示容器启动后会进入其命令行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;设置用户名和UID。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;设置容器内的工作目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;删除容器&#34;&gt;删除容器&lt;/h5&gt;
&lt;p&gt;需要删除一个容器,首先需要确保这个容器已经停止了,因为正在运行的容器是无法直接删除。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker rm 容器名或者容器id
docker rm mysql
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker-desktop/">docker-desktop</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker-desktop/">docker-desktop</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>elasticsearch 安装教程</title>
                <link>/blog/posts/elasticsearch-setup/</link>
                <guid isPermaLink="true">/blog/posts/elasticsearch-setup/</guid>
                <pubDate>Thu, 21 Jan 2021 10:56:59 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h3 id=&#34;elasticsearch-安装教程&#34;&gt;elasticsearch 安装教程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;elasticsearch安装使用版本是7.8.1, 鉴于封装rest_client的版本最高支持8，向下兼容的； 8之后api接口路径调整,可以选择6,7，考虑到项目稳定和技术支持这里选择版本7.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便下载，可以点击&lt;a href=&#34;https://pan.baidu.com/s/1auq9JPJmT3x_yQD0TANgsw&#34;&gt;这里&lt;/a&gt;进行下载； 提取码：c5gy&lt;br&gt;
废话不多说开始进入安装步骤：&lt;/p&gt;
&lt;p&gt;前言：&lt;br&gt;
elasticsearch安装需要配置java环境，篇幅有限，就不介绍怎么安装java了，只需要配置JAVA_HOME环境变量即可。&lt;font color=&#34;#dd0000&#34;&gt;注意必须是java8以上的版本&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;1、将下载的文件解压，将里面的elasticsearch-7.8.1文件夹放到相应目录， 注意目录不能有空格例如&lt;font color=&#34;#dd0000&#34;&gt;d:/Program Files/&lt;/font&gt;  &lt;img src=&#34;/blog/blog/images/elasticsearch/esset-1.png&#34; alt=&#34;文件&#34;&gt;&lt;/p&gt;
&lt;p&gt;2、进入elasticsearch/bin目录，双击执行elasticsearch.bat&lt;img src=&#34;/blog/blog/images/elasticsearch/esset-2.png&#34; alt=&#34;命令&#34;&gt;
执行完毕之后，打开浏览器，输入 http://localhost:9200 ，显式以下画面，说明ES安装成功。
&lt;img src=&#34;/blog/blog/images/elasticsearch/esset-3.png&#34; alt=&#34;命令&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装elasticsearch服务&#34;&gt;安装elasticsearch服务&lt;/h3&gt;
&lt;p&gt;因为上述方法在关闭命令窗口后，elasticsearch会退出关闭，所以安装服务进行启动更合理&lt;br&gt;
1、修改elasticsearch-env.bat文件，将内容&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if &amp;quot;%JAVA_HOME%&amp;quot; == &amp;quot;&amp;quot; (
  set JAVA=&amp;quot;%ES_HOME%\jdk\bin\java.exe&amp;quot;
  set JAVA_HOME=&amp;quot;%ES_HOME%\jdk&amp;quot;
  set JAVA_TYPE=bundled jdk
) else (
  set JAVA=&amp;quot;%JAVA_HOME%\bin\java.exe&amp;quot;
  set JAVA_TYPE=JAVA_HOME
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;替换成&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;set JAVA=&amp;quot;%ES_HOME%\jdk\bin\java.exe&amp;quot;
set JAVA_HOME=&amp;quot;%ES_HOME%\jdk&amp;quot;
set JAVA_TYPE=bundled jdk
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1、打开DOS命令行界面，切换到elasticSearch的bin目录，执行以下命令：&lt;br&gt;
&lt;code&gt;.\elasticsearch-service.bat install &lt;/code&gt;  &lt;img src=&#34;/blog/blog/images/elasticsearch/esset-4.png&#34; alt=&#34;命令&#34;&gt;&lt;/p&gt;
&lt;p&gt;2、打开任务管理器，选择服务,输入e筛选elasticsearch服务&lt;img src=&#34;/blog/blog/images/elasticsearch/esset-5.png&#34; alt=&#34;服务&#34;&gt;, 右键启动即可&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/elasticsearch/">elasticsearch</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/elasticsearch/">elasticsearch</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker学习(六) 自定义tomcat镜像</title>
                <link>/blog/posts/docker-six-custom-image/</link>
                <guid isPermaLink="true">/blog/posts/docker-six-custom-image/</guid>
                <pubDate>Thu, 10 Dec 2020 14:09:32 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker学习六-自定义tomcat镜像center&#34;&gt;&lt;center&gt;Docker学习(六) 自定义tomcat镜像&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;前期准备&#34;&gt;前期准备&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1、tomcat: tomcat版本选择的是apache-tomcat-8.5.61，
    文件名：apache-tomcat-8.5.61.tar.gz
2、java: java版本选择的是JDK1.8.0_211，
    文件名：jdk-8u211-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上文件均可在&lt;a href=&#34;https://pan.baidu.com/s/14-8cf3OLXi841bc_OkpoGA&#34;&gt;这里&lt;/a&gt;下载， 提取码：【tf2u】&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/docker/docker6-1.png&#34; alt=&#34;文件&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dockerfile文件&#34;&gt;Dockerfile文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# centos在这里作为tomcat的基础镜像
FROM centos     
MAINTAINER wmm
#（这个环境变量用来表示该镜像模板的最后更新时间）
ENV REFRESHED_AT 2020-12-10  

# 切换镜像目录，进入/usr目录
WORKDIR /usr
# 在/usr/下创建jdk目录,用来存放jdk文件
RUN mkdir jdk
# 在/usr/下创建tomcat目录，用来存放tomcat
RUN mkdir tomcat

# 将宿主机的jdk目录下的文件拷至镜像的/usr/jdk目录下
ADD jdk-8u211-linux-x64.tar.gz /usr/jdk/
# 将宿主机的tomcat目录下的文件拷至镜像的/usr/tomcat目录下
ADD apache-tomcat-8.5.61.tar.gz /usr/tomcat/

# 给权限
RUN chmod -R 777 /usr/tomcat/
RUN chmod -R 777 /usr/jdk/

# 设置环境变量
ENV JAVA_HOME=/usr/jdk/jdk1.8.0_211
ENV JRE_HOME=$JAVA_HOME/jre
ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH
ENV PATH=/sbin:$JAVA_HOME/bin:$PATH

# 设置时间区域
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;amp;&amp;amp; echo &#39;Asia/Shanghai&#39; &amp;gt;/etc/timezone

# 公开端口
EXPOSE 8080
# 设置启动命令
ENTRYPOINT [&amp;quot;/usr/tomcat/apache-tomcat-8.5.61/bin/catalina.sh&amp;quot;,&amp;quot;run&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打包&#34;&gt;打包&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1、将apache-tomcat-8.5.61.tar.gz、jdk-8u211-linux-x64.tar.gz、Dockerfile放在同一级目录
2、命令进入该目录，执行 docker build -t yuzhi/tomcat .
3、执行完后，使用命令docker images 查看镜像列表。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run -d -p 8080:8080 --name wmm_tomcat yuzhi/tomcat:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;具体执行步骤&#34;&gt;具体执行步骤&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1、进入需要组装镜像的路径
2、执行命令  docker build -t 镜像名:版本号  .	        # 也可以直接是镜像名  这样版本默认是latest
3、docker images   							            # 查看镜像   即可以看到创建的镜像
4、docker run -d -p 映射端口:容器的端口 --name 自定义容器名称 镜像名:版本号   
例如： docker run -d -p 8080:8080 --name wmm_tomcat yuzhi/tomcat:latest
5、docker logs -f --tail=200 容器名称                   # 查看日志
6、docker exec -it 容器名称 /bin/bash			        # 进入容器&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/learn/">learn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker/">docker</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker学习(五) 安装Jenkins实现自动化部署</title>
                <link>/blog/posts/docker-five-jenkins/</link>
                <guid isPermaLink="true">/blog/posts/docker-five-jenkins/</guid>
                <pubDate>Wed, 11 Dec 2019 09:41:13 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker学习五-安装jenkins实现自动化部署项目center&#34;&gt;&lt;center&gt;Docker学习(五) 安装Jenkins实现自动化部署项目&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;安装jenkins&#34;&gt;安装Jenkins&lt;/h3&gt;
&lt;p&gt;玄襄这里为了方便省事，直接使用docker安装Jenkins。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 下载镜像
docker pull jenkins/jenkins:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-1.png&#34; alt=&#34;下载镜像&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 准备宿主挂载的文件夹
mkdir /docker
mkdir /docker/jenkins

# 此处注意 容器需要宿主挂载文件夹的权限  不设置的话  挂载启动会失败
chown -R 1000 /docker/jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-2.png&#34; alt=&#34;准备&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-2-1.png&#34; alt=&#34;权限&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 启动容器
docker run -d --name=jenkins --privileged=true -p 8081:8080 -p 50000:50000 -v /docker/jenkins:/var/jenkins_home jenkins/jenkins

命令解析：
  -p 8081:8080  指定宿主端口8081映射容器8080
  -p 50000:50000 主站进行通信
  -d 后台运行容器
  -v /docker/jenkins:/var/jenkins_home 宿主文件映射容器文件
  --privileged=true  开启特权模式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-3.png&#34; alt=&#34;启动&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;初始化jenkins&#34;&gt;初始化Jenkins&lt;/h3&gt;
&lt;p&gt;jenkins容器已经成功启动了，下面就是初始化jenkins。访问地址 是宿主ip + 8081端口即可访问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开网站 需要登录&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-4.png&#34; alt=&#34;登录&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;密码可以根据网页提示找到文件夹，要注意这里应该是查看宿主文件夹&lt;br&gt;
输入命令  vi /docker/jenkins/secrets/initialAdminPassword   复制密码即可&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-5.png&#34; alt=&#34;密码&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录成功之后，选择安装插件，玄襄这个直接选择推荐的。耐心等待安装完成&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-6.png&#34; alt=&#34;插件&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建第一个admin用户，也可以直接跳过，继续使用admin进行登录，玄襄这里直接跳过了&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-7.png&#34; alt=&#34;admin&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问地址修改，玄襄这里是直接在后面添加 jenkins  此处强烈建议(未来的我)  不要设置jenkins，最好不改url
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-8.png&#34; alt=&#34;url&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化基本完成，登录系统之后修改admin账号&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-9.png&#34; alt=&#34;初始化完成&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins1-10.png&#34; alt=&#34;修改admin密码&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;添加item项目并运行&#34;&gt;添加item项目并运行&lt;/h3&gt;
&lt;h4 id=&#34;安装插件&#34;&gt;安装插件&lt;/h4&gt;
&lt;p&gt;在运行项目之前，jenkins需要安装相应的插件。在jenkins页面 → 系统管理  →  管理插件 →  可选插件 中搜索&lt;br&gt;
插件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Maven Integration       用来支持构建maven项目
  Publish Over SSH        用来把构建好的部署包传送到指定服务器的指定位置
  Git安装
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-2.png&#34; alt=&#34;插件&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-3.png&#34; alt=&#34;插件&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置jenkins&#34;&gt;配置Jenkins&lt;/h3&gt;
&lt;p&gt;jenkins需要配置jdk环境，根据个人项目需求 还涉及到 maven git等配置。这里需要解释下，因为jenkins是运行
在docker上，所以配置要安装宿主挂碍的文件夹/docker/jenkins下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建全局文件夹  执行命令 mkdir /docker/jenkins/globalEnv&lt;/li&gt;
&lt;li&gt;因为玄襄的centos7没有wget， 所以需要下载   yum y install wget&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;maven安装&#34;&gt;maven安装&lt;/h4&gt;
&lt;p&gt;maven选择安装3.6.3的，下载安装完之后  需要设置settings的镜像为阿里镜像，添加路径。具体请跟着玄襄一步步执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 下载maven
wget  http://mirror.bit.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz

# 解压文件
tar -zvxf apache-maven-3.6.3-bin.tar.gz

# 移动文件夹到全局
mv /apache-maven-3.6.3 /docker/jenkins/globalEnv

# 添加阿里镜像
vi /docker/jenkins/globalEnv/apache-maven-3.6.3/conf/settings.xml
  添加下面命令
...
  &amp;lt;mirror&amp;gt;  
      &amp;lt;id&amp;gt;nexus-aliyun&amp;lt;/id&amp;gt;  
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;    
      &amp;lt;name&amp;gt;Nexus aliyun&amp;lt;/name&amp;gt;  
      &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public&amp;lt;/url&amp;gt;  
  &amp;lt;/mirror&amp;gt;
....

# 添加到路径
vi /etc/profile 
  添加下面命令
  M2_HOME=/docker/jenkins/globalEnv/apache-maven-3.6.0   
  export PATH=$M2_HOME/bin:$PATH

# 更新配置文件 
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;jdk安装&#34;&gt;jdk安装&lt;/h4&gt;
&lt;p&gt;jdk安装选择是1.8，因为jdk在官网下载需要登录，所以玄襄直接通过浏览器下载好之后，再上传到虚拟机中的。
&lt;a href=&#34;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&#34;&gt;jdk下载页面&lt;/a&gt; 选择相应版本下载即可
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-4.png&#34; alt=&#34;jdk&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 解压文件
tar -zvxf jdk-8u231-linux-x64.tar.gz
#移动文件
mv /jdk-1.8.0_231 /docker/jenkins/globalEnv

# 添加到路径
vim /etc/profile 
export JAVA_HOME=/docker/jenkins/globalEnv/jdk1.8.0_231
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH

# 更新配置文件 
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-5.png&#34; alt=&#34;安装完毕&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;安装git&#34;&gt;安装git&lt;/h4&gt;
&lt;p&gt;git安装比较简单，执行下面的命令即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc
yum install gcc perl-ExtUtils-MakeMaker
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;jenkins全局环境配置&#34;&gt;jenkins全局环境配置&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先进行jenkins的系统配置，系统管理  → 系统配置  → 添加Publish over SSH 可参照下图：
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-8.png&#34; alt=&#34;系统配置&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-9.png&#34; alt=&#34;ssh&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置全局工具， 系统管理→ 全局工具配置 → maven配置   → jdk安装  → git配置  → maven安装，具体步骤请看下图：&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-6.png&#34; alt=&#34;全局工具配置&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-7.png&#34; alt=&#34;配置添加&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins2-7-1.png&#34; alt=&#34;继续配置添加&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;远程部署项目&#34;&gt;远程部署项目&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在首页点击“ 新建任务 ” 创建新项目，在弹出框中 输入项目名称，选择构建项目类型，玄襄构建的是maven项目，
然后点击 “ 确定 ”。如下图：&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins3-1.png&#34; alt=&#34;创建任务&#34;&gt; &lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins3-2.png&#34; alt=&#34;项目&#34;&gt;&lt;/li&gt;
&lt;li&gt;进入项目配置页面，添加源码管理git仓库，输入git地址  选择git仓库的账户密码， 没有的话，添加即可。
然后记得选择分支，玄襄这里执行的是&lt;font color=&#34;red&#34;&gt;develop&lt;/font&gt;分支&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins3-3.png&#34; alt=&#34;git&#34;&gt;&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins3-3-1.png&#34; alt=&#34;git1&#34;&gt;&lt;/li&gt;
&lt;li&gt;在Build这里的 Goals and options  添加命令   package compile -U&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins3-4.png&#34; alt=&#34;build&#34;&gt;&lt;/li&gt;
&lt;li&gt;注意这里！！！ 这里是最后一步，也是最重要的一步。在build完成之后，要连接远程服务，将编译好的jar包发送过去，
然后执行远程服务的启动项目命令。&lt;br&gt;
首先选择远程服务 →  设置传输的员文件  →  移除前缀  →  远程服务的文件夹  → 执行命令&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/jenkins/jenkins3-5.png&#34; alt=&#34;远程&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 切到目录
cd /home/finance
# 显示工作目录    --- 方便查看
pwd
# 检查该项目是否运行， 是则杀掉
ps -ef | grep yobtc-finance-service| grep -v grep | awk &#39;{print $2}&#39; | xargs --no-run-if-empty kill -9
# 休眠10s
sleep 10
# 使环境变量立即生效
source /etc/profile
# 执行项目setsid  实现后台运行
setsid nohup java -jar  -Xmx512m -Xms512m yobtc-finance-service.jar  &amp;gt; yobtc-finance-service.log &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;保存配置之后，直接点击构建即可。&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/learn/">learn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker/">docker</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker学习(四) 远程部署springboot项目</title>
                <link>/blog/posts/docker-four-springboot/</link>
                <guid isPermaLink="true">/blog/posts/docker-four-springboot/</guid>
                <pubDate>Thu, 05 Dec 2019 09:10:20 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker学习四-远程部署springboot项目center&#34;&gt;&lt;center&gt;Docker学习(四) 远程部署springboot项目&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;远程部署简述&#34;&gt;远程部署简述&lt;/h3&gt;
&lt;p&gt;Docker远程部署项目使用的是DockerFile方式，使用IDEA集成Docker进行发布，使用起来比较方便。&lt;br&gt;
基本过程是：开放远程docker端口，本地连接docker，项目根目录创建DockerFile文件，项目打包，运行dockerFile文件。&lt;/p&gt;
&lt;h3 id=&#34;docker端口开放&#34;&gt;docker端口开放&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 修改配置文件
1. cd /usr/lib/systemd/system
2. vi docker.service
3. 在ExecStart=/usr/bin/dockerd-current 后面添加 -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock -H tcp://0.0.0.0:7654 
解析： 2375为主管理端口，unix://var/run/docker.sock用于本地管理，7654是备用端口
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker/docker4-1.png&#34; alt=&#34;开发端口&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 将管理地址写入/etc/profile
4. echo &#39;export DOCKER_HOST=tcp://0.0.0.0:2375&#39; &amp;gt;&amp;gt; /etc/profile
5. source /etc/profile

# 重新读取配置文件
6. systemctl daemon-reload

# 重启docker服务
7. systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;连接远程docker&#34;&gt;连接远程docker&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;idea安装dokcer插件&lt;br&gt;
打开idea的settings，选择Plugins，搜索插件Docker，安装图片中的插件&lt;img src=&#34;/blog/blog/images/docker/docker4-2.png&#34; alt=&#34;插件&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接远程docker地址&lt;br&gt;
安装完插件之后，添加远程docker的远程地址&lt;img src=&#34;/blog/blog/images/docker/docker4-3.png&#34; alt=&#34;远程&#34;&gt;&lt;br&gt;
在idea的services工具进行连接docker&lt;img src=&#34;/blog/blog/images/docker/docker4-4.png&#34; alt=&#34;连接&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建DockerFile文件
在项目根目录添加dockerFile文件，内容如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  #指定jdk8，注意，改镜像包比较精简，精简掉了如字体等插件  
  #如果需要操作系统字体库，那么就得使用slim版本或者默认版本。需要操作系统字体库的程序例如：图片验证码、PDF导出。  
  #https://segmentfault.com/a/1190000016449865  
  #不涉及到以上问题的，默认请使用openjdk:8-alpine  
  FROM openjdk:8-alpine

  MAINTAINER wmm  
  #tomcat需要  
  VOLUME /tmp   
  #讲jar包加到根目录  
  ADD /target/*.jar app.jar  
  #设置时区  
  RUN echo &amp;quot;Asia/Shanghai&amp;quot; &amp;gt; /etc/timezone  
  RUN ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  
  RUN sh -c &#39;touch /app.jar&#39;  
  RUN echo $(date) &amp;gt; /image_built_at  
  #执行命令  
  ENTRYPOINT [&amp;quot;java&amp;quot;, &amp;quot;-Djava.security.egd=file:/dev/./urandom&amp;quot;, &amp;quot;-jar&amp;quot;,&amp;quot;app.jar&amp;quot;]  
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;镜像启动&lt;br&gt;
使用maven打包项目，然后打开dockerfile文件，点击下面图标&lt;img src=&#34;/blog/blog/images/docker/docker4-5.png&#34; alt=&#34;图标&#34;&gt;&lt;br&gt;
选择编辑运行环境 如下图&lt;img src=&#34;/blog/blog/images/docker/docker4-6.png&#34; alt=&#34;运行环境&#34;&gt;&lt;br&gt;
重新点击上一部的小图标，点击运行即可。&lt;br&gt;
此时远程docker可以通过命令 docker ps -s 看到正在运行的项目
&lt;img src=&#34;/blog/blog/images/docker/docker4-7.png&#34; alt=&#34;启动&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/learn/">learn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker/">docker</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker学习(三) Docker安装mysql</title>
                <link>/blog/posts/docker-three-mysql/</link>
                <guid isPermaLink="true">/blog/posts/docker-three-mysql/</guid>
                <pubDate>Wed, 04 Dec 2019 11:17:31 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker学习三-docker安装mysqlcenter&#34;&gt;&lt;center&gt;Docker学习(三) Docker安装mysql&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;安装mysql简述&#34;&gt;安装mysql简述&lt;/h3&gt;
&lt;p&gt;Docker安装mysql比较方便，主要是以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确认安装mysql的版本 访问Mysql的版本库，点击&lt;a href=&#34;https://hub.docker.com/_/mysql?tab=tags&#34;&gt;这里&lt;/a&gt; 查看版本
&lt;img src=&#34;/blog/blog/images/docker/docker3-1.png&#34; alt=&#34;版本&#34;&gt;&lt;/li&gt;
&lt;li&gt;选择版本后，复制后面的命令  拉取mysql镜像  docker pull mysql:latest
&lt;img src=&#34;/blog/blog/images/docker/docker3-2.png&#34; alt=&#34;mysql&#34;&gt;&lt;/li&gt;
&lt;li&gt;根据mysql镜像启动mysql容器&lt;br&gt;
docker run --name mysql --privileged=true -v /docker/mysql/data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql&lt;br&gt;
参数说明：&lt;br&gt;
run           运行一个容器&lt;br&gt;
--name        容器的名称&lt;br&gt;
--privileged=true  开启特权模式
-v /docker/mysql/data:/var/lib/mysql    将容器中的/var/lib/mysql文件挂载到宿主/docker/mysql/data上，这样删除容器后，数据也不会丢失
-p 3306:3306  表示这个容器使用3306端口(第二个) 映射到本机的端口号也为3306(第一个)&lt;br&gt;
-d            服务后台运行&lt;/li&gt;
&lt;li&gt;外部客户端链接数据库 使用虚拟机的ip + 3306端口  密码是123456即可访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql服务停止和重启&#34;&gt;mysql服务停止和重启&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;docker查看正在运行的容器   $ docker ps -s                &lt;img src=&#34;/blog/blog/images/docker/docker3-3.png&#34; alt=&#34;正在运行的容器&#34;&gt;&lt;/li&gt;
&lt;li&gt;docker停止运行的容器       $ docker stop 5fa83e71137d        5fa83e71137d 是容器id&lt;/li&gt;
&lt;li&gt;docker启动容器            $ docker start 5fa83e71137d&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/learn/">learn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker/">docker</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker学习(二) Docker安装</title>
                <link>/blog/posts/docker-two-docker/</link>
                <guid isPermaLink="true">/blog/posts/docker-two-docker/</guid>
                <pubDate>Tue, 03 Dec 2019 15:31:56 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker学习二-docker安装center&#34;&gt;&lt;center&gt;Docker学习(二) Docker安装&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;docker安装前提准备&#34;&gt;Docker安装前提准备&lt;/h3&gt;
&lt;p&gt;为了操作方便，玄襄这里直接使用root用户执行。docker支持Centos系统的内核版本要高于3.10，首先检查内核，使用uname -r 命令
&lt;img src=&#34;/blog/blog/images/docker/docker2-1.png&#34; alt=&#34;内核版本&#34;&gt;&lt;br&gt;
Centos7满足Docker环境需求，可以继续安装Docker(可能无法正常运行18.06.x及以上版本)。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  # 更新最新yum内核
  yum update -y

  # 卸载旧版的docker(如果安装过的话)
  yum remove docker-*

  # 安装需要的软件包
  yum install -y yum-utils device-mapper-persistent-data lvm2
  
  # 设置yum源  yum-config-manager 是yum-utils下的  一般出现问题可能yum-utils是没有安装好 
  yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker安装&#34;&gt;Docker安装&lt;/h3&gt;
&lt;p&gt;安装有问题的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、 yum install docker-ce     安装完之后，启动不起来  failed to start docker application container engine
    各种搜索 说是版本问题，然后卸载安装的docker
2、 yum install -y docker-ce-18.03.1.ce   依旧启动不起来，同样的错误  
    参照网上的解决方式   使用命令 curl -fsSL https://get.docker.com/ | sh  等待运行完成  问题依旧没有解决
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功历程:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、卸载安装的docker  yum remove docker-*
2、重新更新内核      yum update 
3、然后重启一下系统  reboot
4、安装docker       yum install docker
5、启动docker       systemctl start docker        ---- 很顺利
6、docker版本       docker version
7、docker开启启动   systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/docker/docker2-2.png&#34; alt=&#34;docker版本&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;删除本地文件&#34;&gt;删除本地文件&lt;/h3&gt;
&lt;p&gt;注意，docker 的本地文件，包括镜像(images), 容器(containers), 存储卷(volumes)等，都需要手工删除。默认目录存储在 &lt;font color=#DC143C&gt;/var/lib/docker。&lt;/font&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/learn/">learn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker/">docker</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Docker学习(一) Centos7环境</title>
                <link>/blog/posts/docker-one-centos/</link>
                <guid isPermaLink="true">/blog/posts/docker-one-centos/</guid>
                <pubDate>Tue, 03 Dec 2019 10:11:50 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerdocker学习一-centos7环境center&#34;&gt;&lt;center&gt;Docker学习(一) Centos7环境&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;虚拟机vmware安装&#34;&gt;虚拟机VMware安装&lt;/h3&gt;
&lt;p&gt;玄襄的电脑是windows系统，所以为了模拟线上环境，使用VMware虚拟机创建Centos系统。 玄襄使用的是VMware15 pro版本&lt;br&gt;
为了方便下载，在&lt;a href=&#34;https://pan.baidu.com/s/1VZ4Vg8b5F3TB8wozQ54j8w&#34;&gt;这里&lt;/a&gt;提供了下载链接，网盘密码是【7k58】，有需要的可以下载。
文件如下：
&lt;img src=&#34;/blog/blog/images/docker/docker1.png&#34; alt=&#34;vmware&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装vmware，选择安装位置，中间有可能需要重启，一路下一步直到安装完成。&lt;/li&gt;
&lt;li&gt;安装完之后，打开注册机KeyGen.exe生成key，然后打开vmware应用，把key复制到需要填写的许可证秘钥即可，点击确定破解完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;创建centos7虚拟机&#34;&gt;创建Centos7虚拟机&lt;/h3&gt;
&lt;p&gt;玄襄使用的是Centos7，废话不多说，下载地址在&lt;a href=&#34;https://pan.baidu.com/s/1GoyC5kRicueZ2x_7VggvHg&#34;&gt;这里&lt;/a&gt;，密码【ogv0】。
下载完之后，就可以直接创建虚拟机了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击vmware的文件选项，选择【创建虚拟机】&lt;img src=&#34;/blog/blog/images/docker/docker1-1.png&#34; alt=&#34;创建虚拟机&#34;&gt;，弹出如下向导：&lt;img src=&#34;/blog/blog/images/docker/docker1-2.png&#34; alt=&#34;安装向导&#34;&gt;直接选择【典型(推荐)】即可，点击下一步；&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/blog/blog/images/docker/docker1-3.png&#34; alt=&#34;稍后安装系统&#34;&gt; 此处现在稍后安装系统，点击下一步；&lt;/li&gt;
&lt;li&gt;选择【Linux】操作系统，版本选择【Centos7 64位】，点击下一步；&lt;/li&gt;
&lt;li&gt;【虚拟机名称】和【位置】  根据自己的情况设置即可，点击下一步；&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/blog/blog/images/docker/docker1-4.png&#34; alt=&#34;磁盘大小&#34;&gt; 磁盘大小一般设置20GB, 选择【将虚拟磁盘拆分成多个文件】，点击下一步；&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/blog/blog/images/docker/docker1-5.png&#34; alt=&#34;自定义硬盘&#34;&gt; 选择【自定义硬件】，在【硬件】窗口中选择 【新CD/DVD】,修改右侧的【连接】，使用ISO映像文件，选择本地下载好的镜像文件即可。
&lt;img src=&#34;/blog/blog/images/docker/docker1-6.png&#34; alt=&#34;硬件&#34;&gt;点击关闭， 最后点击完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;centos7系统安装&#34;&gt;Centos7系统安装&lt;/h3&gt;
&lt;p&gt;在上一步创建完虚拟机之后，vmware左侧【我的计算机】菜单会出现创建好的虚拟机。&lt;img src=&#34;/blog/blog/images/centos/centos1-1.png&#34; alt=&#34;开始&#34;&gt;
点击【开启此虚拟机】进行系统安装初始化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启之后  首先我们选择第二个选项 检查并安装Centos7，一堆命令行之后，会出现初始化界面&lt;img src=&#34;/blog/blog/images/centos/centos1-2.png&#34; alt=&#34;初始化&#34;&gt;，推荐默认english，直接continue即可；&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;/blog/blog/images/centos/centos1-3.png&#34; alt=&#34;安装信息摘要&#34;&gt; 出现叹号的地方，需要我们点击进行进行确认，然后点击完成即可。&lt;img src=&#34;/blog/blog/images/centos/centos1-4.png&#34; alt=&#34;目标位置&#34;&gt;，点击开始安装；&lt;/li&gt;
&lt;li&gt;配置界面需要设置下root密码（简单的密码，需要点击2次完成才能设置成功），安装进度条安装完毕后，点击重启即可。&lt;img src=&#34;/blog/blog/images/centos/centos1-5.png&#34; alt=&#34;设置密码&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;centos7网络设置&#34;&gt;Centos7网络设置&lt;/h3&gt;
&lt;p&gt;在新装的Centos系统中，网络基本都是不通的，使用root和密码登录系统之后，使用 ping &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;会出现如图情况 &lt;img src=&#34;/blog/blog/images/centos/centos1-6.png&#34; alt=&#34;ping&#34;&gt;
需要我们重新设置网络&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 ip addr 会发现 eno16777736(文件名可能不一样)，下一步要找到这个文件&lt;img src=&#34;/blog/blog/images/centos/centos1-7.png&#34; alt=&#34;eno&#34;&gt;&lt;/li&gt;
&lt;li&gt;使用 cd /etc/sysconfig/network-scripts/  进入文件中， 使用 dir 命令可以看到 ifcfg-eno16777736 文件&lt;/li&gt;
&lt;li&gt;使用 vi ifcfg-eno16777736  查看内容 按 【i】 进入编辑模式， 将ONBOOT=no改成ONBOOT=yes， 按【esc】退出编辑模式， 使用【:wq】保存并退出vi。 &lt;img src=&#34;/blog/blog/images/centos/centos1-8.png&#34; alt=&#34;内容&#34;&gt;&lt;/li&gt;
&lt;li&gt;使用 service network restart 重启网络服务即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置阿里源&#34;&gt;配置阿里源&lt;/h3&gt;
&lt;p&gt;阿里源地址：&lt;a href=&#34;http://mirrors.aliyun.com/repo/&#34;&gt;http://mirrors.aliyun.com/repo/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载阿里源配置&lt;br&gt;
yum -y install wget&lt;br&gt;
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak&lt;br&gt;
wget -O /etc/yum.repos.d/CentOS-Base.repo &lt;a href=&#34;http://mirrors.aliyun.com/repo/Centos-7.repo&#34;&gt;http://mirrors.aliyun.com/repo/Centos-7.repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;清除缓存并生成新的缓存&lt;br&gt;
yum clean all&lt;br&gt;
yum makecache&lt;/li&gt;
&lt;li&gt;验证是否成功，安装net-tools&lt;br&gt;
yum -y -install net-tools&lt;br&gt;
ifconfig&lt;br&gt;
成功后会出现以下结果：&lt;img src=&#34;/blog/blog/images/centos/centos1-9.png&#34; alt=&#34;ifconfig&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/docker/">docker</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/categories/learn/">learn</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/docker/">docker</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>elasticsearh-rest-client</title>
                <link>/blog/posts/elasticsearh-rest-client/</link>
                <guid isPermaLink="true">/blog/posts/elasticsearh-rest-client/</guid>
                <pubDate>Fri, 22 Nov 2019 10:51:38 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h2 id=&#34;centerelasticsearch-rest-client一center&#34;&gt;&lt;center&gt;elasticsearch rest client(一)&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;low-level-rest-client使用和问题&#34;&gt;low level rest client使用和问题&lt;/h3&gt;
&lt;h4 id=&#34;low-client使用&#34;&gt;low client使用&lt;/h4&gt;
&lt;p&gt;low level rest client使用http与elasticsearch进行通信，不会对请求进行编码和响应编码。它与所有elasticsearch版本兼容。&lt;br&gt;
如果在命令或者语法上有问题，建议查看官方的文档，需要查看java doc的同学可以点击&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.5/java-rest-low.html&#34; title=&#34;文档&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;maven配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.elasticsearch.client&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;elasticsearch-rest-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;7.3.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;elasticsearch配置
restClient可以设置请求头和请求回调。此处不多加叙述，网上介绍有很多，不懂的可以去看看。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Component
@Configuration
public class EsConfig {

	private static final String HTTP_SCHEME = &amp;quot;http&amp;quot;;

	@Value(&amp;quot;${elasticsearch.config.address}&amp;quot;)
	private String ip;

	@Value(&amp;quot;${elasticsearch.config.port}&amp;quot;)
	private Integer port;

	@Bean
	public RestClient client() {
		HttpHost[] hosts = new HttpHost[]{new HttpHost(ip, port, HTTP_SCHEME)};
		RestClientBuilder builder = RestClient.builder(hosts);
		// 添加header
		Header[] defaultHeader = new Header[]{
				// 内容格式
				new BasicHeader(&amp;quot;content-type&amp;quot;, &amp;quot;application/json&amp;quot;),
				// 长连接
				new BasicHeader(&amp;quot;Connection&amp;quot;, &amp;quot;keepalive&amp;quot;),
		};
		builder.setDefaultHeaders(defaultHeader);
		// 默认连接池    线程1
		builder.setHttpClientConfigCallback(httpAsyncClientBuilder -&amp;gt;
				httpAsyncClientBuilder.setDefaultIOReactorConfig(IOReactorConfig.custom().setIoThreadCount(1).build())
		);

		builder.setRequestConfigCallback(builder1 -&amp;gt; builder1
				// 连接超时
				.setConnectTimeout(30000)
				// 数据请求超时
				.setSocketTimeout(40000)
				// 连接池超时设置
				.setConnectionRequestTimeout(0)

		);
		builder.setFailureListener(new RestClient.FailureListener(){
			@Override
			public void onFailure(Node node) {
				super.onFailure(node);
			}
		});

		return  builder.build();
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;封装基层语法
低级客户端的命令都需要进行拼接，所以本人就封装了一下底层，并添加了一个简单的方法封装工具。源代码在&lt;a href=&#34;https://gitee.com/wmmsxm/yuzhi_tools.git&#34; title=&#34;源代码&#34;&gt;gitee&lt;/a&gt;上。
&lt;a href=&#34;/blog/blog/images/elasticsearch/es-2.png&#34;&gt;!工具结构&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;案例
可以参考这个&lt;a href=&#34;https://gitee.com/wmmsxm/btw_learn/tree/master/elasticsearch-seven&#34; title=&#34;案例&#34;&gt;案例&lt;/a&gt;来使用的封装的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;low-client问题&#34;&gt;low client问题&lt;/h4&gt;
&lt;p&gt;封装的low rest client方法中，可能会出现以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Low-level REST client status error:ava.lang.IllegalStateException: Request cannot be executed; I/O reactor status: STOPPED&lt;/p&gt;
&lt;p&gt;这个异常的原因主要是httpClient中的IOReactor被关闭了，原因有很多。出现异常后，再次访问时，就可以正常访问。&lt;br&gt;
查了百度和谷歌，基本上没有能完全解决这个问题的，有的说是内存原因，有的则是减少client链接，或者使用新线程创建client。&lt;br&gt;
本人的解决方式  在restClient.performRequest(request)处捕捉IO异常，再次请求；超过2次(可配)，返回null，异常打印。方式如下图：&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/elasticsearch/es-1.png&#34; alt=&#34;异常处理&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/elasticsearch/">elasticsearch</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/elasticsearch/">elasticsearch</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>zookeeper知识点(三)</title>
                <link>/blog/posts/zookeeper-three/</link>
                <guid isPermaLink="true">/blog/posts/zookeeper-three/</guid>
                <pubDate>Wed, 20 Nov 2019 09:25:10 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h3 id=&#34;zookeeper做一级缓存测试&#34;&gt;zookeeper做一级缓存测试&lt;/h3&gt;
&lt;p&gt;因公司项目需求，准备做一级缓存，然后就想到了zookeeper，都说它性能不错，特地做个测试看下是否可以用于生产。
封装完成使用gitee上的sync_cache项目进行测试。&lt;/p&gt;
&lt;h4 id=&#34;测试前提&#34;&gt;测试前提&lt;/h4&gt;
&lt;p&gt;在服务器上搭建zookeeper集群，最少三个节点。使用sync-cache打包4个项目  分别对应全部节点、每个对应一个不同节点。每个项目都有节点监听和
api入口。&lt;/p&gt;
&lt;h4 id=&#34;测试场景&#34;&gt;测试场景&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用主项目存储比较小的节点数据，测试其他项目的同步时间
测试结果： 主节点 使用1ms ;其他两个节点使用2ms&lt;/li&gt;
&lt;li&gt;使用主项目存储不断循环变大的节点数据，测试其他项目的同步时间
测试结果：  15KB的数据  每个节点相差2ms    就是 主节点2ms    follower1 是4ms   follower2 是6ms。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;结论&#34;&gt;结论&lt;/h4&gt;
&lt;p&gt;上述测试不一定完全符合zookeeper的性能，但是也能看出zookeeper不适合做大数据存储。大项目的时候，在消息同步这块就要垮掉，无法做到一致性（因为有半数机制存在，没有同步完，主节点就已经默认结束了）。
如果非要做一级缓存的话，zookeeper比较适合做热门数据的缓存，数量小的情景.&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/zookeeper/">Zookeeper</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/zookeeper/">Zookeeper</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>zookeeper知识点(二)</title>
                <link>/blog/posts/zookeeper-two/</link>
                <guid isPermaLink="true">/blog/posts/zookeeper-two/</guid>
                <pubDate>Wed, 20 Nov 2019 09:25:10 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h3 id=&#34;zookeeper知识点二&#34;&gt;zookeeper知识点(二)&lt;/h3&gt;
&lt;h4 id=&#34;zookeeper集群&#34;&gt;zookeeper集群&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;zookeeper是由多个server组成的集群，一个leader，一个follower。
leader为客户端服务器提供读写服务，除了leader外其他的机器只能提供读服务。
每个server保存一份数据副本，全数据一致；分布式读follower，写由leader实施更新请求转发。
由leader实施更新请求顺序进行，来自同一个client的更新请求按其发送的顺序依次执行，保持原子性，要么成功，要么失败。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;zookeeper角色&#34;&gt;zookeeper角色&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;leader&lt;/strong&gt;：是整个zookeeper集群工作机制的核心。负责响应所有对Zookeeper状态变更的请求。主要工作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务请求的唯一调度和处理，保持集群处理事务的顺序性&lt;/li&gt;
&lt;li&gt;集群内各服务器的调度者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;leader的选举是zookeeper最重要的技术之一，假如有三个服务器server启动，
每个机器都视图找到一个leader，就进入了leader选举流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个 server 发出一个投票,投票的最基本元素是（SID-服务器id,ZXID-事物id）&lt;/li&gt;
&lt;li&gt;接受来自各个服务器的投票 处理投票&lt;/li&gt;
&lt;li&gt;优先检查 ZXID(数据越新ZXID越大),ZXID比较大的作为leader，ZXID一样的情况下比较SID&lt;/li&gt;
&lt;li&gt;统计投票 这里有个过半的概念，大于集群机器数量的一半，即大于或等于（n/2+1）,我们这里的由三台，大于等于2即为达到“过半”的要求。
这里也有引申到为什么 Zookeeper 集群推荐是单数。&lt;br&gt;
“过半”设计策略也适用在广播通知中，leader在收到过半的follower的ack后，即认为消息抵达了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Follower&lt;/strong&gt;：是zookeeper集群状态的跟随者，，除了响应服务器上的读请求外，还要处理leader的提议。需要注意的是，
leader和follower是构造zookeeper集群的法定人数，只有他们能参与新的leader的选举和响应leader的提议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Observer&lt;/strong&gt;：服务器的观察者。如果 ZooKeeper 集群的读取负载很高，或者客户端多到跨机房，可以设置一些 observer 服务器，以提高读取的吞吐量。
Observer 和 Follower 比较相似，只有一些小区别：首先 observer 不属于法定人数，即不参加选举也不响应提议，也不参与写操作的“过半写成功”策略；
其次是 observer 不需要将事务持久化到磁盘，一旦 observer 被重启，需要从 leader 重新同步整个名字空间。&lt;/p&gt;
&lt;h4 id=&#34;会话session&#34;&gt;会话(Session)&lt;/h4&gt;
&lt;p&gt;Session指的是zookeeper服务器与客户端的会话。在zookeeper中，一个客户端链接是只客户端和服务器之间的一个TCP长连接。
客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。
通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。
Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，
只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。
由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。&lt;/p&gt;
&lt;h4 id=&#34;会话创建&#34;&gt;会话创建&lt;/h4&gt;
&lt;p&gt;session是zookeeper的会话实体，代表了一个客户端会话，其包含了如下四个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sessionID  会话ID，唯一标识的一个会话，每个客户端创建新的会话时，zookeeper都会为其分配一个全局唯一的sessionID&lt;/li&gt;
&lt;li&gt;TimeOut 会话超时时间，客户端构造zookeeper实例时，会配置sessionTimeout参数用于指定会话的超时时间，服务器会根据自己的超时时间限制最后确定会话的超时时间。&lt;/li&gt;
&lt;li&gt;TikTime 下次会话超时时间点，为了便于zookeeper对会话实行“分桶策略”管理，同时为了高效低耗地实现会话的超时检查和清理，zookeeper会为每个会话都标记一个下次会话超时时间点，
其值大致等于当前时间 + timeout&lt;/li&gt;
&lt;li&gt;isClosing。标记一个会话是否已经被关闭，当服务器检测会话已经超时失效时，会将该会话的isClosing标记为&amp;quot;已关闭&amp;quot;，这样就能确保不再处理来自该会话的新请求了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据节点-znode&#34;&gt;数据节点 Znode&lt;/h4&gt;
&lt;p&gt;&amp;quot;节点&amp;quot;分两类，第一类指构成集群的机器，称之机器节点；第二类是数据模型中的数据单元，我们称之数据节点--ZNode。
zookeeper将所有数据存储在内存中，树形存储，每个节点会保存自己的数据内容，还会存储一系列属性信息。&lt;/p&gt;
&lt;h5 id=&#34;节点类型&#34;&gt;节点类型&lt;/h5&gt;
&lt;p&gt;node可以分持久节点和临时节点和顺序节点三大类。可通过组合生成如下四种类型节点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PERSISTENT 持久节点 创建后会一直存在于zookeeper服务器中，直到删除&lt;/li&gt;
&lt;li&gt;PERSISTENT_SEQUENTIAL 持久顺序节点， 相比持久节点，其新增了顺序特性，每个父节点都会为他的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。
在创建节点时，会自动添加一个数字后缀，作为新的节点名，改数字后缀的上限是整形的最大值&lt;/li&gt;
&lt;li&gt;EPEMERAL 临时节点，其生命周期和客户端会话绑定在一起，客户端失效，节点自动删除。&lt;/li&gt;
&lt;li&gt;EPEMERAL_SEQUENTIAL 临时顺序节点  在临时节点上添加了顺序特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;版本--保证分布式数据的原子性操作&#34;&gt;版本--保证分布式数据的原子性操作&lt;/h4&gt;
&lt;p&gt;每个数据节点都具有三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version– 当前数据节点数据内容的版本号&lt;/li&gt;
&lt;li&gt;cversion– 当前数据子节点的版本号&lt;/li&gt;
&lt;li&gt;aversion– 当前数据节点ACL变更版本号&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/zookeeper/">Zookeeper</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/zookeeper/">Zookeeper</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>elasticsearch-bulk</title>
                <link>/blog/posts/elasticsearch-bulk/</link>
                <guid isPermaLink="true">/blog/posts/elasticsearch-bulk/</guid>
                <pubDate>Mon, 18 Nov 2019 10:56:59 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h3 id=&#34;elasticsearch-使用rest-client进行批量操作性能测试&#34;&gt;elasticsearch 使用rest-client进行批量操作性能测试&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;之前做交易所项目， 大量实时数据存储在mongodb中，导致在查询账单、K线会出现查询慢的情况。在优化mongodb的同时，寻找其他
nosql数据库做备用，所以才有了本文的性能测试。
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;elasticsearch-rest-client选择&#34;&gt;elasticsearch rest client选择&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;low level rest client
    1、对elasticsearch版本要求低，封装组件之后，很多项目后续都可以使用；凭借原生json语句。

high level rest client
    1、对elasticsearch版本要求相当高，必须一致，引入的elasticsearch版本也要一致，否则容易报错；
    笔者因为这个吃了不少亏。组件是封装好的，直接拿来使用即可。

在测试环节，elasticsearch使用的版本是7.1.0， 笔者优先使用了low level rest client，对其进行了原生json语句封装。在测试基本创建和其他基本操作时，
效果都不错，但是在批量操作时发现执行比较慢，只能进行优化。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;elasticsearch批量操作优化&#34;&gt;elasticsearch批量操作优化&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1. 调整刷新频率 refresh_interval = -1，手动刷新
2. 仅备份数据时，可以把副本先关掉，完成后再打开 &amp;quot;number_of_replicas&amp;quot;:0
3. 每次数据不能超过5-15MB,数量最好不要超过1000条。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;测试结果&#34;&gt;测试结果&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;1、 low client:   每个文档大约0.016MB
    1. 500个        200ms     
    2. 1000个       500ms
    3. 2000个       1100ms
    4. 4000个       2300ms
可以看出来 随着文档树越多，时间也越长。 如果es要引入交易所，批量必须要达到10000-20000/s,  所以这个不能满足.

2、high client： 每个文档大约0.016MB
同步请求
    1. 500个        250ms
    2. 1000个       480ms
    3. 2000个       970ms
    4. 4000个       1900ms

异步请求  适合做数据备份或者拷贝
    1. 500个        17ms    后台处理回调数据
    2. 1000个       46ms 
    3. 2000个       77ms
    4. 4000ge       180ms
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;结果&#34;&gt;结果&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;笔者最终没有使用elasticsearch，场景所需的条件达不到，只能先放弃，此处仅是记录批量操作性能，方便后期使用。&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/elasticsearch/">elasticsearch</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/elasticsearch/">elasticsearch</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>umi搭建dva</title>
                <link>/blog/posts/umi-dva/</link>
                <guid isPermaLink="true">/blog/posts/umi-dva/</guid>
                <pubDate>Tue, 22 Oct 2019 18:00:35 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h3 id=&#34;umi搭建dva&#34;&gt;umi搭建dva&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;使用umiJs搭建后台管理页面，集成dav、ant，一些react需要的插件不需要手动添加，按需加载即可。  
此处记录安装流程和走过的坑！！
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;安装步骤&#34;&gt;安装步骤&lt;/h4&gt;
&lt;p&gt;一、yarn安装&lt;br&gt;
国内推荐使用yarn，可以直接在&lt;a href=&#34;https://yarn.bootcss.com/docs/install/#windows-stable&#34; title=&#34;yarn官网&#34;&gt;yarn官网&lt;/a&gt;下载安装。 不过本人没有成功 (&lt;em&gt;^▽^&lt;/em&gt;)
或者使用npm install -g yarn 命令进行安装。&lt;/p&gt;
&lt;p&gt;二、下载create-umi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;两种方式  
    1、yarn create umi  
    2、yarn global add create-umi --prefix &amp;quot;D:\Program Files\nodejs\node_global_modules&amp;quot;  

    下载完的create-umi执行失败，系统无法识别，如下所示
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/blog/blog/images/react/20191023141701.png&#34; alt=&#34;错误&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是因为create-umi.cmd里面的盘符前有符号转义，内容如下：
@&amp;quot;%~dp0\C:\Users\wmm\AppData\Local\Yarn\Data\global\node_modules\.bin\create-umi.cmd&amp;quot;   %*

修改为：
@&amp;quot;C:\Users\wmm\AppData\Local\Yarn\Data\global\node_modules\.bin\create-umi.cmd&amp;quot;   %*

保存后，重新运行一下 &amp;quot;create-umi&amp;quot;命令，就可以正常运行了。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、选择project
	? Select the boilerplate type (Use arrow keys)
	  ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.
	&amp;gt; app             - Create project with a simple boilerplate, support typescript.
	  block           - Create a umi block.
	  library         - Create a library with umi.
	  plugin          - Create a umi plugin.
	本人选择了app
	
2、是否使用TypeScript
	? Do you want to use typescript? (y/N)
	y

3、选择需要的插件功能
	? What functionality do you want to enable? (Press &amp;lt;space&amp;gt; to select, &amp;lt;a&amp;gt; to toggle all, &amp;lt;i&amp;gt; to invert selection)
	&amp;gt;◯ antd
	 ◯ dva
	 ◯ code splitting
	 ◯ dll
	此处本人全选

4、最后确定，并使用yarn 安装依赖
	顺利的话  在浏览器打开 [地址](http://localhost:8000 &amp;quot;地址&amp;quot;) 可看到umi界面&lt;/code&gt;&lt;/pre&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/react/">react</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/react/">react</category>
                                
                            
                                
                                
                                
                                    <category domain="/blog/tags/umi/">umi</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>redis集群</title>
                <link>/blog/posts/redis%E9%9B%86%E7%BE%A4/</link>
                <guid isPermaLink="true">/blog/posts/redis%E9%9B%86%E7%BE%A4/</guid>
                <pubDate>Thu, 17 Oct 2019 09:02:40 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;h3 id=&#34;windows搭建redis集群&#34;&gt;windows搭建redis集群&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;操作系统：win10 64位  
redis版本：3.2.100 x64  
ruby版本：2.5.1 x64  
rubygems版本：2.7.6  
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;开场白&#34;&gt;开场白&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;昨天同事需要本地的redis集群环境，在网上找了点资料，历经各种坑，终于搭建完成。今天特地整理一下搭建的流程，加深下印象。
安装工具在百度网盘下载：   
链接：https://pan.baidu.com/s/1LxWEfF8bQGIxd2sxN3N3Pw
提取码：sqmw 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;开始搭建&#34;&gt;开始搭建&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;搭建顺序就是 redis --&amp;gt; 复制多份redis配置 --&amp;gt; 安装ruby --&amp;gt; 安装rubygems --&amp;gt; 进行集群构建脚本
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;redis安装&lt;/p&gt;
&lt;p&gt;下载的redis文件进行解压，最好是放在新的文件夹中，方便集群使用和管理。&lt;br&gt;
&lt;img src=&#34;/blog/blog/images/redis/20191017094637.png&#34; alt=&#34;文件&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置三主三从集群&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为集群最少是6个节点，所以这里配置三主三从，将上面的redis文件夹复制5份，我这边端口修改是6479,6480,6481,6482,6483,6484。如下所示：
&lt;img src=&#34;/blog/blog/images/redis/20191017095130.png&#34; alt=&#34;三主三从&#34;&gt;
其中每一个文件夹都相当于一个redis。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置redis
以6479为例，打开文件夹中的redis.windows.conf文件，分别修改如下数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; port 6479     ---&amp;gt; 端口号，与文件夹保持一致  
 cluster-enabled yes  ---&amp;gt; 开始实例的集群模式  
 cluster-config-file nodes-6479.conf  ---&amp;gt; 设定保存节点配置文件的路径，端口与文件保持一致  
 cluster-node-timeout 15000 ---&amp;gt; 创建集群时超时时间 
 appendonly yes ---&amp;gt; 开启后，每次写操作请求都追加到appendonly.aof 文件中  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意，修改时前面不能有空格！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在每个文件夹中添加一个bat来启动redis，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; title redis-6479         //和当前端口保持一致
 redis-server.exe redis.windows.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建完成之后，分别点击这个bat，启动redis。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装ruby&lt;br&gt;
redis的集群需要ruby环境，所以需要使用下载的rebyinstaller，基本上都勾选，然后一路下一步，最后让你选择，没搞懂啥意思，本人选了3。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装rubygems&lt;br&gt;
解压完成之后，进入文件夹使用powershell，运行如下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1. ruby setup.rb           // 直接安装即可
 2. gem install redis       // 安装redis插件
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;redis-trib.rb
将下载的redis-trib.rb放在redis同级。使用powershell运行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; redis-trib.rb create --replicas 1 127.0.0.1:6479 127.0.0.1:6480 127.0.0.1:6481 127.0.0.1:6482 127.0.0.1:6483 127.0.0.1:6484

 其中会出现Can I set the above configuration? (type &#39;yes&#39; to accept)，输入yes
 最后出现两个OK的时候差不多就是构建成功了。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，如果需要绑定IP地址的话，需要修改redis中的属性 bind 127.0.0.1， 改为bind (你的ip)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/redis/">redis</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/redis/">redis</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>zookeeper知识点(一)</title>
                <link>/blog/posts/zookeeper-one/</link>
                <guid isPermaLink="true">/blog/posts/zookeeper-one/</guid>
                <pubDate>Fri, 09 Aug 2019 19:43:03 &#43;0800</pubDate>
                
                    <author>wmmsxm@163.com (wmmsxm)</author>
                
                <copyright>Copyright © 2022 WuMengMeng</copyright>
                
                    <description>&lt;h3 id=&#34;zookeeper知识点一&#34;&gt;zookeeper知识点(一)&lt;/h3&gt;
&lt;h4 id=&#34;zookeeper简介&#34;&gt;zookeeper简介&lt;/h4&gt;
&lt;p&gt;zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，它可以在分布式系统中协作多个任务。整个Zookeeper的服务器集群管理着应用协作的关键数据。&lt;br&gt;
但是zookeeper不是万能的，它不适合用作海量数据存储。&lt;br&gt;
它主要是提供功能:
1. 保障强一致性、有序性和持久性
2. 实现通用的同步原语的能力
3. 在实际开发中，提供一个简单的并发处理机制，处理并发。&lt;/p&gt;
&lt;h4 id=&#34;zookeeper特性&#34;&gt;zookeeper特性&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;顺序一致性，从同一个客户端发起的事务请求，最终会严格的按照其发起的顺序被应用到zookeeper中。&lt;/li&gt;
&lt;li&gt;原子性， 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么成功应用了，要么都没有应用。&lt;/li&gt;
&lt;li&gt;单一视图， 无聊客户端链接的哪个zookeeper服务器，其看到的服务器数据模型都是一致的。&lt;/li&gt;
&lt;li&gt;可靠性， 一旦服务器成功的应用了一个事务，并完成响应，该事务所引起的服务器状态变更会一直保留，除非有另一个事务对其进行变更。&lt;/li&gt;
&lt;li&gt;实时性， zookeeper保证在一定的时间段内，客户端最终一定能够从服务端读取到最新的数据状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;zookeeper结构&#34;&gt;zookeeper结构&lt;/h4&gt;
&lt;p&gt;zookeeper会维护一个具有层次关系的数据结构，类似于文件系统的层级树状结构。
&lt;img src=&#34;/blog/blog/images/zookeeper/965360-20180418191100883-2107625307.png&#34; alt=&#34;数据模型&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/categories/zookeeper/">Zookeeper</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="/blog/tags/zookeeper/">Zookeeper</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
